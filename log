    def last_day_operation(self,i, dt, ut, tick_price):
        self.__check_loss_cut(i, dt, ut, tick_price)
        self.__check_execution(i, dt, ut, tick_price)
        self.__check_cancel(i, dt, ut, tick_price)
        if self.holding_side != '':
            self.realized_pl += (tick_price - self.holding_price) * self.holding_size if self.holding_side == 'buy' else (self.holding_price -tick_price) * self.holding_size
        self.total_pl = self.realized_pl
        self.num_trade += 1
        self.total_pl_log.append(self.total_pl)
        self.performance_total_pl_log.append(self.total_pl)
        if self.num_trade > 0:
            self.win_rate = self.num_win / self.num_trade
        self.__add_log('Sim Finished.',i,dt,ut,tick_price)
        self.end_dt = dt
        print('from dt={}, : to_dt={}, total p={}, num trade={}, win rate={}'.format(self.start_dt,self.end_dt,self.total_pl,self.num_trade,self.win_rate))



@classmethod
    def ema_trend_follow(cls, stdata, i, ac):
        dd = DecisionData()
        pred_side = 'buy' if stdata.prediction[i] > 0 else 'sell'
        if ac.holding_side == '' and ac.order_side == '' and (pred_side == 'buy' or pred_side == 'sell') : #no position no order
            dd.set_decision(pred_side, 0,cls.__calc_opt_size(stdata.price[i], ac), 'market', False, 10)
        elif (ac.holding_side == 'buy' or ac.holding_side == 'sell') and (pred_side =='buy' or pred_side == 'sell') and \
                ac.holding_side != pred_side and ac.order_side =='':
            dd.set_decision(pred_side, 0,ac.holding_size + cls.__calc_opt_size(stdata.price[i], ac), 'market', False, 10) #exit and re-entry
        return dd


 @classmethod
    def sim_ema_trend_follow(cls, stdata, ac):
        print('sim length:'+str(stdata.dt[0]) + str(stdata.dt[-1]))
        for i in range(len(stdata.prediction)-1):
            dd = Strategy.ema_trend_follow(stdata,i,ac)
            if dd.side != '':
                ac.entry_order(dd.side,dd.price,dd.size,dd.type,dd.expire,i,stdata.dt[i],stdata.ut[i],stdata.price[i])
            ac.move_to_next(i,stdata.dt[i],stdata.ut[i],stdata.price[i])
        ac.last_day_operation(len(stdata.prediction)-1,stdata.dt[len(stdata.prediction)-1],stdata.ut[len(stdata.prediction)-1],stdata.price[len(stdata.prediction)-1])
        return ac



num_term = 500
window_term = 2
kijun = 1000
sim_pl = 100000
period = 11

print(datetime.now(timezone(timedelta(hours=+9), 'JST')))
OneMinMarketData.initialize_for_bot(num_term,window_term, period, kijun,20000)
df = OneMinMarketData.generate_df()
model = CatboostModel()
train_x, test_x, train_y, test_y = model.generate_data(df,1.0)


sim_df = pd.DataFrame()
for k in OneMinMarketData.ohlc.ema_gra:
    start_ind = OneMinMarketData.check_matched_index(test_x)
    stdata = OneMinMarketData.generate_tick_pred_data(test_x['ema_gra'+str(k)], start_ind)
    sim = Sim()
    ac = SimAccount()
    ac = sim.sim_ema_trend_follow(stdata,ac)
    col = 'ema_gra'+str(i)
    sim_df = sim_df.assign(col=ac.performance_total_pl_log)

